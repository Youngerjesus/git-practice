# 협업을 위한 깃 살펴보기 

***

## 브랜치란? 

독립적인 작업 공간을 만들기 위해 사용되는 기능. 

`git status` 명령어를 통해서 현재 작업하고 있는 브랜치를 보는 것도 가능하다. 

브랜치를 생성하는 방법은 크게 두 가지가 있다. 

- 원격 저장소에서 생성한 후 지역 저장소로 가져오기

  - 지역 저장소로 가져오기 위해선 다음과 같은 명령어를 입력하면 된다. `git remote update`

- 지역 저장소에서 만든 후 원격 저장소에 반영하기

지역 저장소와 원격 저장소에 있는 브랜치 리스트를 확인하고 싶다면 `git branch -a` 명령어를 입력하면 된다. 

```
$ git branch -a 

* main
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
  remotes/origin/test
```

- 여기서 * 표시는 현재 작업중인 브랜치를 말한다. 

- remotes/origin 와 같은 접두어가 붙은 브랜치는 원격 저장소를 뜻한다. 

작업할 브랜치를 옮기고 싶다면 `git checkout <브랜치 이름>` 을 통해서 옮길 수 있다. 

만약 작업할 브랜치가 없다면 옮길 수 없다는 메시지가 뜨는데 이 경우에 `git checkout -b <브랜치 이름>` 을 입력하면 브랜치를 생성하면서 작업할 브랜치를 해당 브랜치로 옮긴다. 

브랜치를 삭제하고 싶다면 `git branch -d` 옵션을 통해서 삭제할 브랜치를 지정하면 된다. 

이 명령어는 지역 저장소에 있는 브핸치를 삭제하는 것이고 원격까지 삭제하고 싶다면 `git push origin -d <브랜치 이름>` 을 통해서 반영하면 된다. 

브랜치를 만들고 싶다면 `git branch <브랜치 이름>` 을 통해서 가능하다. 

***

## 브랜치 병합하기 

브랜치 병합은 브랜치의 목적을 알고있다면 이해하기 쉽다.

브랜치의 목적 자체는 독립적으로 작업할 공간을 만들기 위해서다. 

그렇다면 작업이 완료되면 어떨까? 완료된 작업을 이제 합쳐야 하지 않을까? 그래서 이런 합치는 작업을 병합한다고 생각하면 된다. 

이런 병합 방법은 크게 두 가지가 있다. 이를 하나씩 살펴보자.  

### Fast Forward

먼자 작업 환경이 main 브런치가 있고 새로운 작업환경인 test 브런치가 있다고 가정하자. 

이런 상황에서 main 브런치에서 새로운 커밋이 없고 test 브런치에서만 새로운 환경이 있다면 Fast Forward 방식으로 병학이 된다.

Fast Forward 방식은 다른 브랜치에서 작업했던 커밋이 기존 브런치에 합쳐지는 과정을 말한다. 

### 병합 커밋 생성: merge commit 

두 번째 병합 방법은 병합 커밋 생성이다. 

이 방법은 아까 환경을 기준으로 말하면 main 에서 test 브런치를 땃는데 main 에서도 작업을 하고 test 에서도 작업을 한 경우에서 병합을 하는 경우를 말한다. 

즉 한 브런치가 가만히 있는 상태가 아닐 때를 기준으로 말하고 이 경우에 머지를 하면 Auto Merge 로 되서 자동으로 커밋이 만들어져서 추가된다. 

### 충돌 해결하기 

두 번째 병합 같은 경우에는 서로가 작업을 했고 이것들을 가지고 병합을 진행한다. 

그러므로 같은 파일을 작업했을 경우에는 깃은 누가 옳은지 알 수가 없다.

이 경우에는 개발자가 충돌을 해결해줘야 한다. 

충돌이 일어나면 해당 코드에 이런 내용을 볼 수 있다. 

```
<<<<<<<<<<<<<<< HEAD
<현재 브런치의 작업 내역들>

===============
<병합하려는 브런치의 작업 내역들>

>>>>>>>>>>>>>>> <병합하려는 브런치 이름>
``` 

이 내용들을 보고 어떤게 옳은지 개발자가 보고 판단해서 내역을 정리하고 충돌을 해결한 커밋을 내면 된다. 

그러면 병합 충돌을 해결할 수 있다. 

### Merge Strategies 

Git 에서 Merge 하는 전략은 여러개가 있다. 

- Fast Forward

- Recursive

- Ours

- Octopus 

- Resolve

- Subtree

여기서는 제일 많이 사용하는 Fast Forward 와 Recursive 를 알아보겠다. 

Fast Forward 는 줄여서 ff 라고 많이 사용하는데 `git merge` 의 기본 옵션이다. 

그냥 Fast Forward 를 사용할 수 있는 환경이라면 ff 를 자동적으로 사용한다. 

ff 는 커밋 히스토리의 조상이 같을 경우에 사용하는 방식으로 머지를 했을 때 하나의 라인으로 유지시킬 수 있다는 점이 있다. 

Recursive 방식은 `git merge --no-ff` 라는 명령어를 통해서 합칠 수 있는데 커밋 히스토리에서 같은 조상이 아닐때 머지하는 방식으로 새로운 머지 커밋을 만들면서 머지를 하는 방식이다. 

그래서 머지를 했던 시점을 확실하게 알 수 있다는 장점이 있다. 

우아한 형제들에서는 Recursive 방식과 머지 후 해당 브런치를 삭제하는 방식을 이용한다.  

### Pull Request 요청하기 

Pull Request 란 병합을 하기 전에 동료들에게 피드백을 받는 과정이라고 생각하면 된다. 

그냥 바로 병합하면 잘못된 코드가 병합될 수도 있기 때문에 이런 피드백이 필요할 수 있다. 

Pull Request 를 날릴 땐 변경 내역을 검토할 Reviewer 를 선택할 수 있음으로 지정해주는게 좋다. 

Reviewer 는 Pull Request 탭에 있는 [File Changed] 에서 해당 파일들을 보면서 코멘트를 날려줄 수 있고 병합을 승인하거나 거부 할 수 있다. 

이렇게 병합을 원격 저장소에서 했다면 지역 저장소에서 병합 내역을 가지고 오기 위해서는 git pull 을 해야한다.

원격 저장소의 변경 내역을 가지고 오는 git pull 과 git fetch 의 차이에 대해 궁금해 할 수 있는데 git pull 은 병합까지 완료된 상태로 지역 저장소로 가져오는 반면에 git fetch 는 병합은 하지 않은 상태로 가지고 온다. 그래서 git merge 작업이 추가로 필요하다. 
 





